# PLIC 외부 연동 명세 (EXTERNAL INTERFACE)

## 📋 문서 정보

| 항목 | 내용 |
|------|------|
| 문서명 | PLIC External Interface Specification |
| 버전 | 1.3 |
| 작성일 | 2025-01-05 |
| 수정일 | 2025-01-06 |
| 작성자 | PLIC 개발팀 |
| 상태 | **Approved** |
| 역할 | **외부 연동 SSOT** |

---

## 변경 이력

| 버전 | 날짜 | 변경 내용 | 작성자 |
|------|------|-----------|--------|
| 1.0 | 2025-01-05 | 초안 작성 | PLIC 개발팀 |
| 1.1 | 2025-01-06 | CTO 리뷰 반영: 멱등키 설계, 폴링 정책, 웹훅 보안, 로깅 마스킹, 상태 매핑 | PLIC 개발팀 |
| 1.2 | 2025-01-06 | CTO 2차 리뷰 반영: 멱등키 payload 충돌 규칙, orderId 규칙, 웹훅 중복 판정 키, 암호화 정책 정교화, 타임아웃 처리 보완 | PLIC 개발팀 |
| 1.3 | 2025-01-06 | **SSOT 동기화**: orderId/멱등키를 `deal_number` 기준으로 통일, 식별자 체계 명확화 | PLIC 개발팀 |

---

## 1. 개요

### 1.1 문서 목적

이 문서는 PLIC 서비스가 연동하는 모든 외부 시스템의 인터페이스를 정의합니다. 개발자가 "외부 API를 어떻게 호출하고, 어떤 응답을 받는지"를 명확히 이해하기 위한 **단일 진실 공급원(SSOT)**입니다.

### 1.2 연동 시스템 목록

| 시스템 | 제공사 | 용도 | 연동 방식 |
|--------|--------|------|-----------|
| **PG (결제)** | 소프트페이먼트 | 카드 결제, 빌링키 발급 | REST API + 웹훅 |
| **송금 (펌뱅킹)** | TBD (쿠콘, 세틀뱅크 등) | 계좌 송금, 실명조회 | REST API |
| **본인인증** | TBD (PASS, KCB 등) | 휴대폰 본인확인 | REST API + Redirect |
| **SMS** | TBD (알리고, NHN 등) | 문자 발송 | REST API |
| **푸시** | Firebase (FCM) | 앱 푸시 알림 | REST API |

### 1.3 공통 원칙

| 원칙 | 설명 |
|------|------|
| **멱등성** | 모든 결제/송금 API는 멱등키 사용 |
| **타임아웃** | 외부 API 호출 시 타임아웃 필수 설정 |
| **재시도** | 일시적 오류에 대해서만 재시도 (RETRYABLE) |
| **로깅** | 모든 요청/응답을 감사 로그에 기록 (마스킹 적용) |

### 1.3.0 식별자 체계 ⚠️ (v1.3 SSOT 동기화)

> ⚠️ **핵심**: 외부 연동에서는 `deal_number`만 사용, `deal_id`는 내부 PK로만 사용

| 식별자 | 형식 | 용도 | 예시 |
|--------|------|------|------|
| `deal_id` | UUID | 내부 PK, API 참조 | `deal_abc123xyz` |
| `deal_number` | `PLIC_DYYYYMMDD_NNNNN` | **외부 연동, 대사, 정산** | `PLIC_D20250106_00001` |

**적용 범위**:
- PG 결제: `orderId = deal_number`
- 송금: `externalIdempotencyKey = deal_number`
- 대사: 매칭 키 = `deal_number`
- 정산: 참조 키 = `deal_number`

### 1.3.1 암호화 정책 ⚠️ (v1.2 정교화)

| 구분 | 방식 | 대상 | 비고 |
|------|------|------|------|
| **전송 암호화** | TLS 1.2+ 필수 | 모든 외부 API 통신 | 추가 애플리케이션 암호화 불필요 |
| **저장 암호화** | KMS 암호화 | CI/DI, 계좌번호 원문 | DB 레벨 암호화 |
| **저장 해시** | SHA-256 | CI (중복가입 검증용) | 원문 복호화 불필요 시 |
| **로그 마스킹** | 1.4절 참조 | 모든 민감정보 | 원문 로깅 금지 |

> ⚠️ **주의**: 전송 계층은 TLS로 충분. 불필요한 커스텀 암호화는 오히려 취약점 발생 가능

### 1.4 감사 로그 마스킹 정책 ⚠️ (v1.1 추가)

| 데이터 유형 | 저장 방식 | 예시 |
|------------|----------|------|
| 계좌번호 | 마지막 4자리만 | `***456789` |
| 카드번호 | 앞6뒤4 (BIN + 마지막4) | `512345******1234` |
| 휴대폰번호 | 뒤 4자리만 | `***5678` |
| CI/DI | KMS 암호화 또는 해시만 저장 | `sha256:abc...` |
| 예금주명 | 가운데 마스킹 | `홍*동` |
| CVV/CVC | **절대 저장 금지** | - |

> ⚠️ **원문 저장 금지**, 보관 기간: 5년 (전자금융거래법)

---

## 2. PG 연동 (소프트페이먼트)

### 2.1 개요

| 항목 | 내용 |
|------|------|
| 제공사 | 소프트페이먼트 |
| Base URL | `https://api.softpayment.co.kr` (운영) |
| 인증 방식 | API Key + Secret (HMAC 서명) |
| 데이터 형식 | JSON |
| PCI-DSS | SAQ-A (SDK 토큰화) |

### 2.2 빌링키 발급 (SDK 직접 연동)

> ⚠️ **카드 정보는 PLIC 서버를 거치지 않음** - 클라이언트 SDK에서 직접 PG로 전송

```
[사용자 앱] → [소프트페이먼트 SDK] → [소프트페이먼트 서버]
                    ↓
              빌링키 반환
                    ↓
            [PLIC 서버로 전달]
```

**SDK 초기화 (클라이언트)**
```javascript
const softpay = new SoftPayment({
  clientKey: 'YOUR_CLIENT_KEY',
  environment: 'production' // 'sandbox' for test
});

// 빌링키 발급 요청
const result = await softpay.issueBillingKey({
  cardNumber: '5123450000001234',
  expiryYear: '28',
  expiryMonth: '12',
  cardPassword2: '12',  // 앞 2자리
  birthOrBusinessNo: '900101'  // 생년월일 6자리 또는 사업자번호 10자리
});

// 성공 시 PLIC 서버로 빌링키 전달
if (result.success) {
  await fetch('/api/cards', {
    method: 'POST',
    body: JSON.stringify({
      billingKey: result.billingKey,
      cardCompany: result.cardCompany,
      cardNumberLast4: result.last4
    })
  });
}
```

**SDK 응답 (성공)**
```json
{
  "success": true,
  "billingKey": "BK_abc123xyz789",
  "cardCompany": "SHINHAN",
  "last4": "1234",
  "cardType": "CREDIT"
}
```

**SDK 응답 (실패)**
```json
{
  "success": false,
  "errorCode": "CARD_INVALID",
  "errorMessage": "유효하지 않은 카드입니다."
}
```

### 2.3 결제 승인

**POST** `/v1/payments/billing`

**Request Headers**
```
Authorization: Bearer {api_key}
X-Signature: {hmac_signature}
X-Timestamp: {unix_timestamp}
Content-Type: application/json
```

**Request Body**
```json
{
  "orderId": "PLIC_D20250106_001",
  "billingKey": "BK_abc123xyz789",
  "amount": 110000,
  "orderName": "PLIC 송금 서비스",
  "customerName": "홍길동",
  "customerPhone": "01012345678",
  "metadata": {
    "dealId": "deal_001",
    "transferAmount": 100000,
    "feeAmount": 10000
  }
}
```

> ⚠️ **orderId는 PLIC deal 단위로 고정** - 재시도 시에도 동일한 orderId 사용 (멱등성 보장)

### 2.3.1 orderId 규칙 ⚠️ (v1.3 SSOT 동기화)

> ⚠️ **v1.3 변경**: `PLIC_D{dealId}` → `deal_number` 사용으로 통일

| 결제 유형 | orderId 형식 | 예시 | 비고 |
|----------|-------------|------|------|
| **단건 결제** (v1.0) | `deal_number` | `PLIC_D20250106_00001` | DB deals.deal_number 값 사용 |
| **분할 결제** (v1.1+) | `{deal_number}_S{sliceNo}` | `PLIC_D20250106_00001_S1` | 회차별 구분 |

> ⚠️ **주의**: 
> - `deal_id` (UUID)는 외부 연동에 **절대 사용 금지**
> - `deal_number`는 거래 생성 시 자동 발급되는 시퀀스 기반 외부 식별자

**재시도 원칙**
```
- 동일 deal(단건) 또는 동일 slice(분할)에 대해서만 동일 orderId 사용
- PG의 orderId 멱등성을 활용하여 중복 승인 방지
- 회차별 결제는 서로 다른 orderId 필요 (PG 충돌 방지)
```

**Response (성공)**
```json
{
  "resultCode": "0000",
  "resultMessage": "Success",
  "paymentKey": "PK_20250106_abc123",
  "orderId": "PLIC_D20250106_001",
  "status": "DONE",
  "approvedAt": "2025-01-06T10:30:00+09:00",
  "amount": 110000,
  "card": {
    "company": "SHINHAN",
    "number": "512345******1234",
    "installmentMonth": 0,
    "approvalNumber": "12345678"
  }
}
```

**Response (실패)**
```json
{
  "resultCode": "4001",
  "resultMessage": "잔액 부족",
  "errorCode": "INSUFFICIENT_BALANCE"
}
```

### 2.4 결제 취소

**POST** `/v1/payments/{paymentKey}/cancel`

**Request Body**
```json
{
  "cancelReason": "고객 요청",
  "cancelAmount": 110000
}
```

**Response**
```json
{
  "resultCode": "0000",
  "paymentKey": "PK_20250106_abc123",
  "status": "CANCELED",
  "canceledAt": "2025-01-06T11:00:00+09:00",
  "cancelAmount": 110000,
  "cancelReason": "고객 요청"
}
```

### 2.5 결제 조회

**GET** `/v1/payments/{paymentKey}`

**Response**
```json
{
  "resultCode": "0000",
  "paymentKey": "PK_20250106_abc123",
  "orderId": "PLIC_D20250106_001",
  "status": "DONE",
  "amount": 110000,
  "approvedAt": "2025-01-06T10:30:00+09:00"
}
```

### 2.6 외부 → 내부 상태 매핑 ⚠️ (v1.1 추가, v1.2 명확화)

> ⚠️ **v1.0 범위**: 분할 결제 제외. PG 상태는 Payment 엔티티에 직접 매핑  
> 분할 결제 도입 시: PG 상태 → PaymentSlice 매핑, Payment는 aggregate 상태

**단건 결제 (v1.0)**

| PG 상태 | PLIC Payment 상태 | 비고 |
|---------|-------------------|------|
| `DONE` | `PAID` | 결제 완료 |
| `CANCELED` | `CANCELLED` | 결제 취소 |
| `PARTIAL_CANCELED` | `PARTIALLY_REFUNDED` | 부분 취소 |
| `FAILED` | `FAILED` | 결제 실패 |
| `WAITING_FOR_DEPOSIT` | - | PLIC 미사용 (가상계좌) |

**분할 결제 (v1.1+ 예정)**

| PG 상태 | PLIC PaymentSlice 상태 | Payment 상태 | 비고 |
|---------|----------------------|--------------|------|
| `DONE` | `PAID` | 유지/PARTIALLY_PAID | 회차 완료 |
| `CANCELED` | `CANCELLED` | 재계산 | 회차 취소 |
| `FAILED` | `FAILED` | 재계산 | 회차 실패 |

### 2.7 웹훅

**POST** `{PLIC_WEBHOOK_URL}/webhooks/softpayment`

**Request Headers**
```
X-Webhook-Signature: {hmac_sha256_signature}
X-Webhook-Timestamp: {unix_timestamp}
Content-Type: application/json
```

**Request Body**
```json
{
  "eventType": "PAYMENT.DONE",
  "paymentKey": "PK_20250106_abc123",
  "orderId": "PLIC_D20250106_001",
  "status": "DONE",
  "amount": 110000,
  "createdAt": "2025-01-06T10:30:00+09:00"
}
```

**웹훅 보안 정책** ⚠️ (v1.1 추가)

```javascript
// 1. 리플레이 방지 - 타임스탬프 검증
const MAX_WEBHOOK_AGE_MS = 5 * 60 * 1000; // 5분
const webhookTimestamp = parseInt(headers['X-Webhook-Timestamp']) * 1000;
const now = Date.now();

if (Math.abs(now - webhookTimestamp) > MAX_WEBHOOK_AGE_MS) {
  return res.status(401).json({ error: 'Webhook expired' });
}

// 2. 서명 검증 - constant-time compare (타이밍 공격 방지)
const expectedSignature = crypto
  .createHmac('sha256', WEBHOOK_SECRET)
  .update(`${webhookTimestamp}.${JSON.stringify(body)}`)
  .digest('hex');

const receivedSignature = headers['X-Webhook-Signature'];

if (!crypto.timingSafeEqual(
  Buffer.from(expectedSignature),
  Buffer.from(receivedSignature)
)) {
  // 내부 알림 발송 (보안 이벤트)
  await alertSecurityTeam('Webhook signature mismatch');
  return res.status(401).json({ error: 'Invalid signature' });
}

// 3. 중복 처리 방지 (v1.2 보완: eventType 포함)
const eventKey = body.eventId  // PG가 eventId 제공 시 사용
  || `${body.paymentKey}:${body.eventType}:${body.createdAt}`;  // 없으면 복합키

const existingEvent = await pgWebhookEvents.findByEventKey(eventKey);
if (existingEvent) {
  return res.status(200).json({ status: 'already_processed' });
}

// 이벤트 처리 후 저장
await processWebhookEvent(body);
await pgWebhookEvents.save({
  provider: 'SOFTPAYMENT',
  eventKey,
  paymentKey: body.paymentKey,
  eventType: body.eventType,
  payload: body,
  processedAt: new Date()
});
```

### 2.7.1 웹훅 중복 판정 키 ⚠️ (v1.2 추가)

> ⚠️ **주의**: 동일 paymentKey로 여러 eventType이 올 수 있음 (DONE → PARTIAL_CANCELED → CANCELED)

**중복 판정 키 우선순위**

| 우선순위 | 키 | 설명 |
|----------|---|------|
| 1 | `eventId` | PG가 제공하는 고유 이벤트 ID (가장 안전) |
| 2 | `(paymentKey, eventType, createdAt)` | eventId 없을 시 복합키 |
| 3 | `payload hash` | 최후 수단 (SHA-256) |

**pg_webhook_events 테이블 유니크 제약**
```sql
-- 권장: provider + eventKey 조합
UNIQUE INDEX idx_webhook_events_unique ON pg_webhook_events(provider, event_key);

-- 또는: 복합키
UNIQUE INDEX idx_webhook_events_composite 
  ON pg_webhook_events(provider, payment_key, event_type, created_at);
```

**이벤트 타입별 처리**

| eventType | 처리 | 비고 |
|-----------|------|------|
| `PAYMENT.DONE` | Payment 상태 → PAID | 송금 트리거 |
| `PAYMENT.CANCELED` | Payment 상태 → CANCELLED | 전체 취소 |
| `PAYMENT.PARTIAL_CANCELED` | Payment 상태 → PARTIALLY_REFUNDED | 부분 취소 |
| `PAYMENT.FAILED` | Payment 상태 → FAILED | 결제 실패 |

**웹훅 응답 전략**

| 상황 | HTTP 응답 | 처리 |
|------|-----------|------|
| 서명 불일치 | 401 Unauthorized | 내부 보안 알림 |
| 타임스탬프 만료 | 401 Unauthorized | 리플레이 공격 의심 |
| 중복 이벤트 | 200 OK | 재처리 방지 |
| 처리 성공 | 200 OK | 정상 완료 |
| 서버 오류 | 500 Internal Server Error | PG 재시도 트리거 |

### 2.8 PG 에러 코드

| 에러 코드 | 설명 | 분류 | PLIC 처리 |
|-----------|------|------|-----------|
| 0000 | 성공 | - | - |
| 4001 | 잔액 부족 | FATAL | 결제 실패 처리 |
| 4002 | 한도 초과 | FATAL | 결제 실패 처리 |
| 4003 | 카드 정지 | FATAL | 결제 실패 처리 |
| 4004 | 분실/도난 카드 | FATAL | 결제 실패 + 카드 비활성화 |
| 4005 | 유효기간 만료 | FATAL | 결제 실패 + 카드 비활성화 |
| 5001 | PG 시스템 오류 | RETRYABLE | 재시도 (최대 3회) |
| 5002 | 카드사 응답 없음 | RETRYABLE | 재시도 (최대 3회) |
| 5003 | 네트워크 오류 | RETRYABLE | 재시도 (최대 3회) |

---

## 3. 송금 연동 (펌뱅킹)

### 3.1 개요

| 항목 | 내용 |
|------|------|
| 제공사 | TBD (쿠콘, 세틀뱅크, 헥토파이낸셜 등) |
| Base URL | `https://api.transfer-provider.co.kr` (예시) |
| 인증 방식 | API Key + IP Whitelist |
| 데이터 형식 | JSON |

### 3.2 계좌 실명조회

**POST** `/v1/accounts/verify`

**Request Body**
```json
{
  "bankCode": "088",
  "accountNumber": "110123456789",
  "holderName": "홍길동",
  "holderBirthDate": "19900101"
}
```

**Response (성공 - 일치)**
```json
{
  "resultCode": "0000",
  "verified": true,
  "bankCode": "088",
  "accountNumber": "110123456789",
  "holderName": "홍길동",
  "matchResult": "EXACT"
}
```

**Response (성공 - 불일치)**
```json
{
  "resultCode": "0000",
  "verified": false,
  "bankCode": "088",
  "accountNumber": "110123456789",
  "actualHolderName": "홍*동",
  "matchResult": "MISMATCH"
}
```

### 3.3 송금 요청

**POST** `/v1/transfers`

**Request Headers**
```
Authorization: Bearer {api_key}
X-Idempotency-Key: {idempotency_key}
Content-Type: application/json
```

**Request Body**
```json
{
  "transferId": "PLIC_T20250106_001",
  "fromAccount": {
    "bankCode": "088",
    "accountNumber": "PLIC_OPERATIONAL_ACCOUNT"
  },
  "toAccount": {
    "bankCode": "004",
    "accountNumber": "123456789012",
    "holderName": "김영희"
  },
  "amount": 100000,
  "memo": "PLIC 송금",
  "requestedAt": "2025-01-06T10:31:00+09:00"
}
```

### 3.4 멱등키 설계 ⚠️ (v1.3 SSOT 동기화)

```javascript
// ✅ 올바른 설계: deal_number 단위 고정 (v1.3)
const idempotencyKey = deal.dealNumber;  // 예: "PLIC_D20250106_00001"

// ❌ 잘못된 설계: 시도 횟수 포함 (중복 송금 위험!)
const idempotencyKey = `${deal.dealNumber}_${attemptCount}`;  // 위험!

// ❌ 잘못된 설계: deal_id(UUID) 사용
const idempotencyKey = `PLIC_T${dealId}`;  // UUID는 외부 연동에 부적합
```

> ⚠️ **v1.3 변경점**: 
> - 송금 멱등키도 `deal_number` 사용 (PG orderId와 동일 체계)
> - 시도 횟수를 멱등키에 포함하면 외부 송금사 입장에서 "서로 다른 요청"으로 인식  
> - 네트워크 타임아웃 발생 시 실제로는 성공했는데 다음 시도에서 **중복 송금** 발생 가능

**시도 횟수 관리**
```
- 멱등키: deal_number 단위 고정 (외부 송금사 전달)
- attempt: 내부 transfer_jobs 테이블에서만 관리
```

### 3.4.1 멱등키 Payload 충돌 규칙 ⚠️ (v1.2 추가)

동일한 멱등키로 **다른 요청 본문**이 들어오는 케이스 처리:

```javascript
// 멱등키 요청 처리 로직
async function handleIdempotentRequest(idempotencyKey, requestBody) {
  const requestHash = crypto
    .createHash('sha256')
    .update(JSON.stringify(requestBody))
    .digest('hex');
  
  const existing = await idempotencyStore.findByKey(idempotencyKey);
  
  if (existing) {
    // Case 1: 동일 키 + 동일 payload → 저장된 응답 반환
    if (existing.requestHash === requestHash) {
      return existing.responseSnapshot;
    }
    
    // Case 2: 동일 키 + 다른 payload → 409 Conflict
    throw new ConflictError({
      code: 'IDEMPOTENCY_KEY_CONFLICT',
      message: '동일한 멱등키로 다른 요청이 이미 존재합니다.',
      existingRequestHash: existing.requestHash,
      newRequestHash: requestHash
    });
  }
  
  // 새 요청 처리 후 저장
  const response = await processTransfer(requestBody);
  
  await idempotencyStore.save({
    idempotencyKey,
    requestHash,
    responseSnapshot: response,
    ttl: 24 * 60 * 60 * 1000  // 24시간
  });
  
  return response;
}
```

**멱등키 저장 항목**

| 필드 | 설명 |
|------|------|
| `idempotency_key` | 멱등키 (PK) |
| `request_hash` | 요청 본문 SHA-256 해시 |
| `response_snapshot` | 응답 스냅샷 (JSON) |
| `created_at` | 생성 시각 |
| `expires_at` | 만료 시각 (created_at + 24h) |

> ⚠️ **중요**: Payload 충돌 시 409 Conflict로 거절하여 "잘못된 계좌로의 재시도" 같은 치명적 사고 방지

**Response (성공)**
```json
{
  "resultCode": "0000",
  "transferId": "PLIC_T20250106_001",
  "externalTransferId": "EXT_TR_abc123",
  "status": "COMPLETED",
  "completedAt": "2025-01-06T10:31:05+09:00",
  "amount": 100000,
  "fee": 500
}
```

**Response (처리 중)**
```json
{
  "resultCode": "0000",
  "transferId": "PLIC_T20250106_001",
  "externalTransferId": "EXT_TR_abc123",
  "status": "PROCESSING",
  "expectedCompletionAt": "2025-01-06T10:32:00+09:00"
}
```

### 3.5 PROCESSING 상태 폴링 정책 ⚠️ (v1.1 추가)

```
[PROCESSING 상태 처리 흐름]

1. 초기 폴링 (적극적)
   - 10초 간격 × 6회 (1분간)
   
2. 중기 폴링 (여유)
   - 5분 후 1회
   - 30분 후 1회
   - 2시간 후 1회
   
3. 여전히 PROCESSING → MANUAL_REVIEW 전환
   - 환불/재송금 경합 방지
   - 수동 대사 필요 플래그 설정
   - 관리자 알림 발송
   
4. 24시간 후에도 미확정
   - 송금사 직접 문의 (고객센터 연락)
   - 대사 티켓 생성
```

**폴링 구현 예시**
```javascript
const POLLING_SCHEDULE = [
  { delay: 10000, count: 6 },   // 10초 × 6회
  { delay: 300000, count: 1 },  // 5분 × 1회
  { delay: 1800000, count: 1 }, // 30분 × 1회
  { delay: 7200000, count: 1 }, // 2시간 × 1회
];

async function pollTransferStatus(transferId: string) {
  for (const schedule of POLLING_SCHEDULE) {
    for (let i = 0; i < schedule.count; i++) {
      await sleep(schedule.delay);
      
      const result = await transferApi.getStatus(transferId);
      
      if (result.status === 'COMPLETED') {
        return { success: true, status: 'COMPLETED' };
      }
      if (result.status === 'FAILED') {
        return { success: false, status: 'FAILED', failureType: result.failureType };
      }
      // PROCESSING 계속 → 다음 폴링
    }
  }
  
  // 모든 폴링 완료 후에도 PROCESSING
  await flagForManualReview(transferId);
  return { success: false, status: 'MANUAL_REVIEW' };
}
```

### 3.6 송금 결과 조회

**GET** `/v1/transfers/{transferId}`

**Response**
```json
{
  "resultCode": "0000",
  "transferId": "PLIC_T20250106_001",
  "status": "COMPLETED",
  "amount": 100000,
  "completedAt": "2025-01-06T10:31:05+09:00"
}
```

### 3.7 외부 → 내부 상태 매핑 ⚠️ (v1.1 추가)

| 송금사 상태 | PLIC Transfer 상태 | 비고 |
|------------|-------------------|------|
| `COMPLETED` | `COMPLETED` | 송금 성공 |
| `PROCESSING` | `PROCESSING` | 폴링 필요 |
| `FAILED` | `FAILED` | failure_type 확인 |
| `CANCELED` | `CANCELLED` | 송금 취소 |
| `RETURNED` | `RETURNED` | 사후 반환 (v1.2) |

### 3.7.1 송금 사후 반환 처리 ⚠️ (v1.2 추가)

> ⚠️ **주의**: 송금 성공(COMPLETED) 후에도 수취인 계좌 상태에 따라 은행 단계에서 **사후 반환**될 수 있음

**반환 사유**

| 반환 코드 | 사유 | 발생 시점 |
|----------|------|----------|
| `RETURN_DORMANT` | 휴면 계좌 | 수 시간 ~ 1일 |
| `RETURN_SEIZURE` | 압류 계좌 | 수 시간 ~ 1일 |
| `RETURN_LIMIT` | 입금 한도 초과 | 즉시 ~ 수 시간 |
| `RETURN_OTHER` | 기타 사유 | 다양 |

**처리 흐름**
```
[송금 사후 반환 처리]

1. 반환 웹훅 수신 (송금사 → PLIC)
   ├─ Transfer 상태: COMPLETED → RETURNED
   ├─ Deal 상태: COMPLETED → TRANSFER_RETURNED
   └─ 감사 로그 기록

2. 운영 자금 복구
   ├─ 반환 금액 운영 계좌로 자동 입금 (송금사 처리)
   └─ operational_fund_balance 업데이트

3. 사용자 알림 및 환불 처리
   ├─ 결제 취소 진행 (PG API)
   └─ 사용자 푸시/SMS 알림

4. 최종 확인 배치 (권장)
   ├─ 매일 06:00 실행
   ├─ 전일 COMPLETED 건 중 반환 여부 재확인
   └─ 웹훅 누락 방지
```

### 3.8 송금 에러 코드

| 에러 코드 | 설명 | 분류 | failure_type | PLIC 처리 |
|-----------|------|------|--------------|-----------|
| 0000 | 성공 | - | - | - |
| 3001 | 예금주 불일치 | FATAL | `HOLDER_MISMATCH` | 즉시 ABANDONED |
| 3002 | 계좌 없음 | FATAL | `ACCOUNT_NOT_FOUND` | 즉시 ABANDONED |
| 3003 | 계좌 해지 | FATAL | `ACCOUNT_CLOSED` | 즉시 ABANDONED |
| 3004 | 입금 불가 계좌 | FATAL | `DEPOSIT_RESTRICTED` | 즉시 ABANDONED |
| 5001 | 은행 점검 중 | RETRYABLE | `BANK_MAINTENANCE` | 점검 후 재시도 |
| 5002 | 은행 응답 없음 | RETRYABLE | `BANK_TIMEOUT` | 재시도 (최대 5회) |
| 5003 | 네트워크 오류 | RETRYABLE | `NETWORK_ERROR` | 재시도 (최대 5회) |
| 5004 | 시스템 오류 | RETRYABLE | `SYSTEM_ERROR` | 재시도 (최대 5회) |

**failure_type 처리 로직**
```javascript
switch (failureType) {
  case 'HOLDER_MISMATCH':
  case 'ACCOUNT_NOT_FOUND':
  case 'ACCOUNT_CLOSED':
  case 'DEPOSIT_RESTRICTED':
    // FATAL: 즉시 ABANDONED, 환불 프로세스 시작
    await deal.transitionTo('ABANDONED');
    await initiateRefund(deal.paymentId);
    break;
    
  case 'BANK_MAINTENANCE':
  case 'BANK_TIMEOUT':
  case 'NETWORK_ERROR':
  case 'SYSTEM_ERROR':
    // RETRYABLE: 자동 재시도 (최대 5회)
    if (attempt < 5) {
      await scheduleRetry(dealId, calculateBackoff(attempt));
    } else {
      await deal.transitionTo('ABANDONED');
      await initiateRefund(deal.paymentId);
    }
    break;
}
```

### 3.9 은행 점검 시간

| 은행 | 코드 | 점검 시간 | 비고 |
|------|------|-----------|------|
| KB국민 | 004 | 23:50~00:10 | - |
| 신한 | 088 | 23:55~00:05 | - |
| 우리 | 020 | 23:55~00:05 | - |
| 하나 | 081 | 23:50~00:10 | - |
| NH농협 | 011 | 23:50~00:30 | 점검 길이 주의 |
| 기업 | 003 | 23:50~00:10 | - |
| SC제일 | 023 | 23:50~00:10 | - |
| 케이뱅크 | 089 | 00:00~00:10 | - |
| 카카오뱅크 | 090 | 23:50~00:05 | - |
| 토스뱅크 | 092 | 23:55~00:05 | - |

> ⚠️ 점검 시간은 변경될 수 있음. API 응답 코드 우선 적용, 이 표는 참고용

### 3.9.1 점검 시간 코드화 권장 ⚠️ (v1.2 추가)

```javascript
// 점검 시간을 Config/DB로 관리하여 불필요한 API 호출 방지
const bankMaintenanceConfig = {
  '004': { start: '23:50', end: '00:10' },  // KB국민
  '088': { start: '23:55', end: '00:05' },  // 신한
  '011': { start: '23:50', end: '00:30' },  // NH농협
  // ...
};

function isBankInMaintenance(bankCode: string): boolean {
  const config = bankMaintenanceConfig[bankCode];
  if (!config) return false;
  
  const now = new Date();
  const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
  
  // 자정 전후 처리 포함
  return isTimeInRange(currentTime, config.start, config.end);
}

// 송금 요청 전 체크
if (isBankInMaintenance(recipientBankCode)) {
  throw new ServiceUnavailableError({
    code: 'BANK_MAINTENANCE',
    message: '해당 은행 점검 시간입니다. 잠시 후 다시 시도해주세요.',
    retryAfter: calculateMaintenanceEnd(recipientBankCode)
  });
}
```

> ⚠️ **주의**: 실제 점검 여부는 API 응답 코드(`BANK_MAINTENANCE`)가 최종 판단 기준

---

## 4. 본인인증 연동

### 4.1 개요

| 항목 | 내용 |
|------|------|
| 제공사 | TBD (PASS, KCB 등) |
| 인증 방식 | API Key |
| 인증 유형 | 휴대폰 본인확인 (PASS) |

### 4.2 PASS 인증 요청

**POST** `/v1/auth/pass/request`

**Request Body**
```json
{
  "requestId": "PLIC_AUTH_20250106_001",
  "returnUrl": "https://plic.co.kr/auth/callback",
  "cancelUrl": "https://plic.co.kr/auth/cancel",
  "purpose": "SIGNUP"
}
```

**Response**
```json
{
  "resultCode": "0000",
  "requestId": "PLIC_AUTH_20250106_001",
  "authUrl": "https://pass.auth.provider/auth?token=abc123",
  "expiresAt": "2025-01-06T10:35:00+09:00"
}
```

### 4.3 PASS 인증 결과 조회

**GET** `/v1/auth/pass/{requestId}/result`

**Response (성공)**
```json
{
  "resultCode": "0000",
  "requestId": "PLIC_AUTH_20250106_001",
  "verified": true,
  "ci": "encrypted_ci_value",
  "di": "encrypted_di_value",
  "name": "홍길동",
  "phone": "01012345678",
  "birthDate": "19900101",
  "gender": "M",
  "carrier": "SKT"
}
```

### 4.3.1 CI/DI 보관 정책 ⚠️ (v1.2 추가)

> 상세 정책은 **PLIC_SECURITY.md** 참조

| 항목 | 정책 | 비고 |
|------|------|------|
| **CI 저장** | SHA-256 해시 저장 | 중복가입 검증용 |
| **CI 원문** | KMS 암호화 후 별도 저장 | 필요 시에만 복호화 |
| **DI 저장** | KMS 암호화 | 서비스별 식별자 |
| **탈퇴 후 보관** | CI 해시만 5년 보관 | 재가입 차단용 |
| **재가입 정책** | 탈퇴 후 30일 이내 불가 | CI 해시로 검증 |

### 4.4 SMS 인증 (간편 인증)

**POST** `/v1/auth/sms/send`

**Request Body**
```json
{
  "phone": "01012345678",
  "purpose": "CARD_REGISTRATION"
}
```

**Response**
```json
{
  "resultCode": "0000",
  "verificationId": "SMS_V_abc123",
  "expiresAt": "2025-01-06T10:33:00+09:00"
}
```

**POST** `/v1/auth/sms/verify`

**Request Body**
```json
{
  "verificationId": "SMS_V_abc123",
  "code": "123456"
}
```

**Response**
```json
{
  "resultCode": "0000",
  "verified": true
}
```

### 4.5 본인인증 에러 코드

| 에러 코드 | 설명 | 처리 |
|-----------|------|------|
| 0000 | 성공 | - |
| 2001 | 인증 시간 초과 | 재인증 요청 |
| 2002 | 인증 실패 (3회 초과) | 일정 시간 후 재시도 |
| 2003 | 인증 코드 불일치 | 재입력 요청 |
| 2004 | 이미 사용된 인증 | 새 인증 요청 |

---

## 5. 알림 연동

### 5.1 SMS 발송

**POST** `/v1/sms/send`

**Request Body**
```json
{
  "to": "01012345678",
  "from": "15881234",
  "content": "[PLIC] 송금이 완료되었습니다. 금액: 100,000원",
  "type": "LMS"
}
```

**Response**
```json
{
  "resultCode": "0000",
  "messageId": "MSG_20250106_abc123",
  "sentAt": "2025-01-06T10:31:10+09:00"
}
```

### 5.2 FCM 푸시

**POST** `https://fcm.googleapis.com/v1/projects/{project_id}/messages:send`

**Request Body**
```json
{
  "message": {
    "token": "user_fcm_token",
    "notification": {
      "title": "송금 완료",
      "body": "100,000원이 성공적으로 송금되었습니다."
    },
    "data": {
      "type": "TRANSFER_COMPLETE",
      "dealId": "deal_001"
    }
  }
}
```

---

## 6. 코드표

### 6.1 은행 코드

| 코드 | 은행명 | 비고 |
|------|--------|------|
| 001 | 한국은행 | - |
| 002 | 산업은행 | - |
| 003 | 기업은행 | - |
| 004 | KB국민은행 | - |
| 007 | 수협은행 | - |
| 011 | NH농협은행 | - |
| 012 | 지역농축협 | - |
| 020 | 우리은행 | - |
| 023 | SC제일은행 | - |
| 027 | 씨티은행 | - |
| 031 | 대구은행 | - |
| 032 | 부산은행 | - |
| 034 | 광주은행 | - |
| 035 | 제주은행 | - |
| 037 | 전북은행 | - |
| 039 | 경남은행 | - |
| 045 | 새마을금고 | - |
| 048 | 신협 | - |
| 050 | 저축은행 | - |
| 071 | 우체국 | - |
| 081 | 하나은행 | - |
| 088 | 신한은행 | - |
| 089 | 케이뱅크 | 인터넷전문 |
| 090 | 카카오뱅크 | 인터넷전문 |
| 092 | 토스뱅크 | 인터넷전문 |

### 6.2 카드사 코드

| 코드 | 카드사명 | 비고 |
|------|----------|------|
| 01 | 비씨 | - |
| 02 | KB국민 | - |
| 03 | 하나(외환) | - |
| 04 | 삼성 | - |
| 06 | 신한 | - |
| 07 | 현대 | - |
| 08 | 롯데 | - |
| 11 | NH농협 | - |
| 12 | 수협 | - |
| 13 | 씨티 | - |
| 14 | 우리 | - |
| 15 | 카카오뱅크 | - |
| 16 | 케이뱅크 | - |
| 21 | 광주 | - |
| 22 | 전북 | - |
| 23 | 제주 | - |
| 24 | 토스뱅크 | - |

---

## 7. 타임아웃 정책

### 7.1 API별 타임아웃

| API | 연결 타임아웃 | 읽기 타임아웃 | 비고 |
|-----|--------------|--------------|------|
| 빌링키 발급 | 5초 | 30초 | SDK 처리 |
| 결제 승인 | 5초 | 60초 | 카드사 응답 대기 |
| 결제 취소 | 5초 | 60초 | - |
| 결제 조회 | 5초 | 10초 | - |
| 계좌 실명조회 | 5초 | 15초 | 은행 응답 대기 |
| 송금 요청 | 5초 | 60초 | 은행 응답 대기 |
| 송금 조회 | 5초 | 10초 | - |
| 본인인증 | 5초 | 30초 | - |

### 7.2 타임아웃 처리 ⚠️ (v1.2 보완)

> ⚠️ **핵심 원칙**: 타임아웃 ≠ 실패. 반드시 **조회 API로 상태 확인 후** 판단

```
[타임아웃 발생 시 처리 흐름]

1. 결제 승인 타임아웃
   ┌─ 타임아웃 발생
   ↓
   결제 조회 API 호출 (GET /v1/payments/{orderId})
   ↓
   ├─ 성공(DONE): 정상 처리 (Payment → PAID)
   ├─ 실패(FAILED): 실패 처리
   ├─ 미존재(404): 결제 미발생, 재시도 가능
   └─ 조회도 타임아웃: 5분 대기 후 재조회, 3회 실패 시 수동 확인

2. 송금 타임아웃
   ┌─ 타임아웃 발생
   ↓
   송금 결과 조회 API 호출 (GET /v1/transfers/{transferId})
   ↓
   ├─ 성공(COMPLETED): 상태 업데이트 (Transfer → COMPLETED)
   ├─ 처리중(PROCESSING): 폴링 스케줄 진입 (섹션 3.5)
   ├─ 실패(FAILED): failure_type에 따라 처리
   └─ 미존재(404): 송금 미발생 가능, 동일 멱등키로 재시도

3. 타임아웃 로깅 및 알림
   ├─ 모든 타임아웃 발생 건 감사 로그 기록
   ├─ 10분 내 3회 이상 발생 시 관리자 알림
   └─ 조회 결과와 무관하게 타임아웃 자체를 로깅
```

**⚠️ 금지 사항**
```javascript
// ❌ 절대 금지: 타임아웃 발생 시 바로 실패 처리
try {
  await paymentApi.approve(request);
} catch (e) {
  if (e.code === 'ETIMEDOUT') {
    payment.status = 'FAILED';  // 위험! 실제로는 성공했을 수 있음
  }
}

// ✅ 올바른 처리: 조회 후 판단
try {
  await paymentApi.approve(request);
} catch (e) {
  if (e.code === 'ETIMEDOUT') {
    // 조회로 실제 상태 확인
    const status = await paymentApi.getStatus(orderId);
    if (status === 'DONE') {
      payment.status = 'PAID';  // 타임아웃이었지만 실제 성공
    } else if (status === 'FAILED') {
      payment.status = 'FAILED';
    } else {
      // 조회도 실패 시 pending 유지, 재조회 스케줄링
      await scheduleStatusCheck(orderId);
    }
  }
}
```

---

## 부록

### A. 환경별 설정

| 환경 | PG Base URL | 송금 Base URL | 인증 Base URL |
|------|-------------|---------------|---------------|
| 로컬 | Mock Server | Mock Server | Mock Server |
| 개발 | Sandbox | Sandbox | Sandbox |
| 스테이징 | Sandbox | Sandbox | Sandbox |
| 운영 | Production | Production | Production |

### B. 참고 문서

| 문서 | 관계 |
|------|------|
| PLIC_PRD.md | 연동 정책 요약 |
| PLIC_STATE_MACHINES.md | failure_type 처리, 상태 전이 |
| PLIC_FUNDS_FLOW.md | 자금 흐름 |
| PLIC_API_SPEC.md | PLIC 내부 API |
| PLIC_RECONCILIATION_SETTLEMENT.md | 대사/정산 |
| PLIC_SECURITY.md | CI/DI 보관, 암호화 정책 |
| PLIC_CODEBOOK.md | 은행/카드 코드표 (분리 권장) |
